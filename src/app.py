# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/180x7ZWRcvjMu-h8fBgTfirb9uR-uSNm7
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import re

st.set_page_config(page_title="Car Insurance Claim Prediction", page_icon="üöó", layout="wide")
st.title("Car Insurance Claim Prediction")

st.sidebar.title("Navigation")
page = st.sidebar.radio('Go to', ['Home', 'Data Overview', 'Prediction'])

if page == "Home":
    st.title("üöó Car Insurance Claim Prediction App")
    st.image('images/image1.png', caption='Insurance Predictor',use_column_width=True)

    st.markdown(
        """
        Welcome!
        This app uses a machine learning model to predict whether a **car insurance policy**
        is likely to result in a **claim** based on vehicle, policy and customer details.
        """
    )

    st.markdown("### üîç What does this app do?")
    st.markdown(
        """
        - Takes in key information about the **car** (make, fuel type, power, torque, safety features, etc.).
        - Uses a trained **XGBoost / Random Forest / CatBoost** model (best model chosen by CV AUC).
        - Outputs whether a **claim is likely (1)** or **not likely (0)**, and can be extended to show probabilities.
        """
    )

    st.markdown("### üíº Why is this useful?")
    st.markdown(
        """
        - **Pricing** ‚Äì Help actuaries or data teams design risk-based premiums.
        - **Risk Management** ‚Äì Flag high-risk policies for extra checks.
        - **Operations** ‚Äì Forecast possible claim load and plan resources.
        """
    )

    st.markdown("### üìå How to use this app")
    st.markdown(
        """
        1. Go to the **Data Overview** tab to understand the dataset.
        2. Go to the **Prediction** tab.
        3. Enter details of a policy / vehicle in the form.
        4. Click **Predict Claim** to see the model‚Äôs output.
        """
    )


elif page == "Data Overview":
    st.title("üìä Data Overview")
    st.image('images/image2.png', caption='Insurance Predictor',use_column_width=True)

    st.markdown(
    """
    ## üìù Comprehensive Data Overview

    This dataset contains detailed information about **car insurance policies**,
    the **policyholder**, and the **vehicle attributes** used to predict whether
    a customer will file an insurance claim (`is_claim`) during the policy period.
    Below is a complete description of all available features:

    ---

    ## üîπ Policy & Customer Information

    **`policy_id`**
    - Unique identifier for each insurance policy.

    **`policy_tenure`**
    - Duration (in years) that the policy has been active.

    **`age_of_car`**
    - Normalized age of the insured vehicle.

    **`age_of_policyholder`**
    - Normalized age of the customer holding the insurance.

    **`area_cluster`**
    - Encoded geographic region of the customer, representing socio-economic segments.

    **`population_density`**
    - Density of the policyholder‚Äôs city, which affects traffic conditions and accident risk.

    ---

    ## üöó Vehicle Details

    **`make`**
    - Encoded manufacturer/brand of the car.

    **`model`**
    - Encoded specific model of the car.

    **`segment`**
    - Category of the car (A, B1, B2, C1, C2), indicating its class and intended usage.

    **`fuel_type`**
    - Type of fuel (Petrol, Diesel, CNG, Electric, etc.).

    **`engine_type`**
    - Structure/format of the vehicle's engine (e.g., DOHC, SOHC, Turbo).

    **`displacement`**
    - Engine displacement (in cc), indicating engine size.

    **`cylinder`**
    - Number of cylinders in the engine.

    **`transmission_type`**
    - Transmission mode (Manual, Automatic, AMT, CVT, etc.).

    **`gear_box`**
    - Number of forward gears in the car.

    **`rear_brakes_type`**
    - Type of rear braking system (Drum / Disc).

    **`steering_type`**
    - Type of power steering mechanism (Hydraulic / Electric / Manual).

    ---

    ## ‚öôÔ∏è Vehicle Performance Metrics

    **`max_power`** (bhp@rpm)
    - Maximum horsepower output by the engine.

    **`max_torque`** (Nm@rpm)
    - Maximum torque produced.

    These were further decomposed in preprocessing into:
    - `max_power_value`
    - `max_power_rpm`
    - `max_torque_value`
    - `max_torque_rpm`

    ---

    ## üìè Vehicle Dimensions & Handling

    **`length` / `width` / `height`**
    - Dimensions of the vehicle body.

    **`turning_radius`**
    - Minimum metre radius needed for the vehicle to turn.

    **`gross_weight`**
    - Maximum permissible total weight (vehicle + passengers + cargo).

    ---

    ## üõ°Ô∏è Safety Features

    The dataset includes numerous binary safety indicators:

    - `airbags` ‚Äî Number of airbags installed
    - `is_esc` ‚Äî Electronic Stability Control
    - `is_adjustable_steering` ‚Äî Steering wheel adjustment
    - `is_tpms` ‚Äî Tyre Pressure Monitoring System
    - `is_parking_sensors` ‚Äî Rear/front parking sensors
    - `is_parking_camera` ‚Äî Parking assistance camera
    - `is_front_fog_lights`
    - `is_rear_window_wiper`
    - `is_rear_window_washer`
    - `is_rear_window_defogger`
    - `is_brake_assist`
    - `is_power_door_locks`
    - `is_central_locking`
    - `is_power_steering`
    - `is_driver_seat_height_adjustable`
    - `is_day_night_rear_view_mirror`
    - `is_ecw` ‚Äî Engine Check Warning
    - `is_speed_alert` ‚Äî Speed alerting system

    **`ncap_rating`**
    - Safety rating assigned by NCAP (1‚Äì5 stars).

    These features significantly contribute to the risk profile of the vehicle
    and likelihood of accidents or safety system engagement.

    ---

    ## üìå Target Variable

    **`is_claim`**
    - Binary indicator representing whether the policyholder filed a claim.
    - **1** ‚Üí Claim filed
    - **0** ‚Üí No claim

    This is the target column used for model training and prediction.

    ---

    ## üßÆ Engineered Features (created during preprocessing)

    To improve prediction accuracy, additional derived variables were added:

    - **`power_to_weight`** ‚Äî max power divided by vehicle weight
    - **`torque_to_weight`** ‚Äî torque divided by weight
    - **`car_age_ratio`** ‚Äî vehicle age relative to policy tenure
    - **`engine_efficiency`** ‚Äî displacement per unit power

    These provide deeper insight into vehicle performance and usage behavior.

    ---

    This overview should help you understand the structure, purpose, and importance
    of each feature before exploring model predictions or dataset samples.
    """
)




elif page == 'Prediction':
    st.title('Prediction')

    # Load model & encoders
    model = joblib.load('models/best_model_XGBoost.pkl')
    encoders = joblib.load("models/all_encoders.pkl")

    st.subheader("Categorical Fields")
    fuel_type = st.selectbox("Fuel Type", encoders['fuel_type'].classes_)
    rear_brakes_type = st.selectbox("Rear Brakes Type", encoders['rear_brakes_type'].classes_)
    transmission_type = st.selectbox("Transmission Type", encoders['transmission_type'].classes_)
    steering_type = st.selectbox("Steering Type", encoders['steering_type'].classes_)
    model_sel = st.selectbox("Model", encoders['model'].classes_)
    engine_type = st.selectbox("Engine Type", encoders['engine_type'].classes_)
    segment = st.selectbox("Segment", encoders['segment'].classes_)
    area_cluster = st.selectbox("Area Cluster", encoders['area_cluster'].classes_)

    st.subheader("Numeric Fields")
    numeric_cols = [
        "policy_tenure", "age_of_car", "age_of_policyholder", "population_density",
        "airbags", "displacement", "cylinder", "turning_radius", "length",
        "width", "height", "gross_weight", "ncap_rating", "gear_box","make"
    ]
    user_input = {}
    for col in numeric_cols:
        user_input[col] = st.number_input(col.replace("_", " ").title(), min_value=0.0)

    st.subheader("Torque & Power")
    user_input["max_power_value"] = st.number_input("Max Power Value (Integer) in bhp", placeholder="e.g., 60")
    user_input["max_torque_value"] = st.number_input("Max Torque Value (Integer) in Nm", placeholder="e.g., 60")
    user_input["max_power_rpm"] = st.number_input("Max Power RPM (Value) in rpm", placeholder="e.g., 3500")
    user_input["max_torque_rpm"] = st.number_input("Max Torque RPM (Integer) in rpm", placeholder="e.g., 3500")

    st.subheader("Boolean Fields")
    boolean_cols = [
        "is_esc", "is_adjustable_steering", "is_tpms", "is_parking_sensors",
        "is_parking_camera", "is_front_fog_lights", "is_rear_window_wiper",
        "is_rear_window_washer", "is_rear_window_defogger", "is_brake_assist",
        "is_power_door_locks", "is_central_locking", "is_power_steering",
        "is_driver_seat_height_adjustable", "is_day_night_rear_view_mirror",
        "is_ecw", "is_speed_alert"
    ]
    for col in boolean_cols:
        val = st.selectbox(col.replace("_", " ").title(), ["Yes", "No"])
        user_input[col] = 1 if val == "Yes" else 0



   #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Encode categorical
    user_input['fuel_type'] = encoders['fuel_type'].transform([fuel_type])[0]
    user_input['rear_brakes_type'] = encoders['rear_brakes_type'].transform([rear_brakes_type])[0]
    user_input['transmission_type'] = encoders['transmission_type'].transform([transmission_type])[0]
    user_input['steering_type'] = encoders['steering_type'].transform([steering_type])[0]
    user_input['model'] = encoders['model'].transform([model_sel])[0]
    user_input['engine_type'] = encoders['engine_type'].transform([engine_type])[0]
    user_input['segment'] = encoders['segment'].transform([segment])[0]
    user_input['area_cluster'] = encoders['area_cluster'].transform([area_cluster])[0]

    # Interaction features
    eps = 1e-6
    user_input['power_to_weight'] = user_input['max_power_value'] / (user_input['gross_weight'] + eps)
    user_input['torque_to_weight'] = user_input['max_torque_value'] / (user_input['gross_weight'] + eps)
    user_input['car_age_ratio'] = user_input['age_of_car'] / (user_input['policy_tenure'] + 1.0)
    user_input['engine_efficiency'] = user_input['displacement'] / (user_input['max_power_value'] + eps)

    # Ensure correct feature order

    input_df = pd.DataFrame([user_input])



    dtypes = {
    'policy_tenure': 'float64',
    'age_of_car': 'float64',
    'age_of_policyholder': 'float64',
    'area_cluster': 'int64',
    'population_density': 'int64',
    'make': 'int64',
    'segment': 'int64',
    'model': 'int64',
    'fuel_type': 'int64',
    'engine_type': 'int64',
    'airbags': 'int64',
    'is_esc': 'int64',
    'is_adjustable_steering': 'int64',
    'is_tpms': 'int64',
    'is_parking_sensors': 'int64',
    'is_parking_camera': 'int64',
    'rear_brakes_type': 'int64',
    'displacement': 'int64',
    'cylinder': 'int64',
    'transmission_type': 'int64',
    'gear_box': 'int64',
    'steering_type': 'int64',
    'turning_radius': 'float64',
    'length': 'int64',
    'width': 'int64',
    'height': 'int64',
    'gross_weight': 'int64',
    'is_front_fog_lights': 'int64',
    'is_rear_window_wiper': 'int64',
    'is_rear_window_washer': 'int64',
    'is_rear_window_defogger': 'int64',
    'is_brake_assist': 'int64',
    'is_power_door_locks': 'int64',
    'is_central_locking': 'int64',
    'is_power_steering': 'int64',
    'is_driver_seat_height_adjustable': 'int64',
    'is_day_night_rear_view_mirror': 'int64',
    'is_ecw': 'int64',
    'is_speed_alert': 'int64',
    'ncap_rating': 'int64',
    'max_power_value': 'float64',
    'max_power_rpm': 'float64',
    'max_torque_value': 'float64',
    'max_torque_rpm': 'float64',
    'power_to_weight': 'float64',
    'torque_to_weight': 'float64',
    'car_age_ratio': 'float64',
    'engine_efficiency': 'float64'}

    # 1. Convert all columns to numeric using your dtypes dict
    for col, col_type in dtypes.items():
        input_df[col] = input_df[col].astype(col_type)

    # 2. Align to booster feature order
    booster_features = model.get_booster().feature_names
    for col in booster_features:
      if col not in input_df.columns:
          input_df[col] = 0
    input_df = input_df[booster_features]



    # 3. Convert to float32 for XGBoost
    for col in input_df.select_dtypes(include=['float64']).columns:
        input_df[col] = input_df[col].astype(np.float32)

    for col in input_df.select_dtypes(include=['int64']).columns:
        input_df[col] = input_df[col].astype(np.int32)







    if st.button("Predict Claim"):

        prediction = model.predict(input_df)[0]
        st.write("Prediction:", prediction)

