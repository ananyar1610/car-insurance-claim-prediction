# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/180x7ZWRcvjMu-h8fBgTfirb9uR-uSNm7
"""

import streamlit as st
import pandas as pd
import numpy as np
import joblib
import re

st.set_page_config(page_title="Car Insurance Claim Prediction", page_icon="üöó", layout="wide")
st.title("Car Insurance Claim Prediction")

st.sidebar.title("Navigation")
page = st.sidebar.radio('Go to', ['Home', 'Data Overview', 'Prediction'])

if page == "Home":
    st.title("üöó Car Insurance Claim Prediction App")
    st.image('images/image1.png', caption='Insurance Predictor',use_column_width=True)

    st.markdown(
        """
        Welcome!
        This app uses a machine learning model to predict whether a **car insurance policy**
        is likely to result in a **claim** based on vehicle, policy and customer details.
        """
    )

    st.markdown("### üîç What does this app do?")
    st.markdown(
        """
        - Takes in key information about the **car** (make, fuel type, power, torque, safety features, etc.).
        - Uses a trained **XGBoost / Random Forest / CatBoost** model (best model chosen by CV AUC).
        - Outputs whether a **claim is likely (1)** or **not likely (0)**, and can be extended to show probabilities.
        """
    )

    st.markdown("### üíº Why is this useful?")
    st.markdown(
        """
        - **Pricing** ‚Äì Help actuaries or data teams design risk-based premiums.
        - **Risk Management** ‚Äì Flag high-risk policies for extra checks.
        - **Operations** ‚Äì Forecast possible claim load and plan resources.
        """
    )

    st.markdown("### üìå How to use this app")
    st.markdown(
        """
        1. Go to the **Data Overview** tab to understand the dataset.
        2. Go to the **Prediction** tab.
        3. Enter details of a policy / vehicle in the form.
        4. Click **Predict Claim** to see the model‚Äôs output.
        """
    )


elif page == "Data Overview":
    st.title("üìä Data Overview")
    st.image('images/image2.png', caption='Insurance Predictor',use_column_width=True)

    if df_train is None:
        st.info(
            "No `train.csv` file found in the app directory.\n\n"
            "‚Ä¢ Place your training data as `train.csv` in the same folder as `app.py`,\n"
            "  or update the path in `load_train_data()`.\n"
            "‚Ä¢ Once the file is present, this page will automatically show summary stats."
        )
    else:
        # basic shape
        n_rows, n_cols = df_train.shape
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Rows", f"{n_rows:,}")
        with col2:
            st.metric("Columns", n_cols)
        with col3:
            if "is_claim" in df_train.columns:
                st.metric("Claim Rate", f"{df_train['is_claim'].mean():.2%}")
            else:
                st.metric("Claim Rate", "N/A")

        st.markdown("---")

        st.markdown("### üëÄ Sample rows")
        st.dataframe(df_train.head(20), use_container_width=True)

        st.markdown("### ‚ÑπÔ∏è Column information")
        info_df = (
            df_train.dtypes.reset_index()
            .rename(columns={"index": "column", 0: "dtype"})
        )
        st.dataframe(info_df, use_container_width=True)

        if "is_claim" in df_train.columns:
            st.markdown("### üéØ Target distribution (`is_claim`)")
            st.bar_chart(df_train["is_claim"].value_counts().sort_index())



elif page == 'Prediction':
    st.title('Prediction')

    # Load model & encoders
    model = joblib.load('models/best_model_XGBoost.pkl')
    encoders = joblib.load("models/all_encoders.pkl")

    st.subheader("Categorical Fields")
    fuel_type = st.selectbox("Fuel Type", encoders['fuel_type'].classes_)
    rear_brakes_type = st.selectbox("Rear Brakes Type", encoders['rear_brakes_type'].classes_)
    transmission_type = st.selectbox("Transmission Type", encoders['transmission_type'].classes_)
    steering_type = st.selectbox("Steering Type", encoders['steering_type'].classes_)
    model_sel = st.selectbox("Model", encoders['model'].classes_)
    engine_type = st.selectbox("Engine Type", encoders['engine_type'].classes_)
    segment = st.selectbox("Segment", encoders['segment'].classes_)
    area_cluster = st.selectbox("Area Cluster", encoders['area_cluster'].classes_)

    st.subheader("Numeric Fields")
    numeric_cols = [
        "policy_tenure", "age_of_car", "age_of_policyholder", "population_density",
        "airbags", "displacement", "cylinder", "turning_radius", "length",
        "width", "height", "gross_weight", "ncap_rating", "gear_box","make"
    ]
    user_input = {}
    for col in numeric_cols:
        user_input[col] = st.number_input(col.replace("_", " ").title(), min_value=0.0)

    st.subheader("Torque & Power")
    user_input["max_power_value"] = st.number_input("Max Power Value (Integer) in bhp", placeholder="e.g., 60")
    user_input["max_torque_value"] = st.number_input("Max Torque Value (Integer) in Nm", placeholder="e.g., 60")
    user_input["max_power_rpm"] = st.number_input("Max Power RPM (Value) in rpm", placeholder="e.g., 3500")
    user_input["max_torque_rpm"] = st.number_input("Max Torque RPM (Integer) in rpm", placeholder="e.g., 3500")

    st.subheader("Boolean Fields")
    boolean_cols = [
        "is_esc", "is_adjustable_steering", "is_tpms", "is_parking_sensors",
        "is_parking_camera", "is_front_fog_lights", "is_rear_window_wiper",
        "is_rear_window_washer", "is_rear_window_defogger", "is_brake_assist",
        "is_power_door_locks", "is_central_locking", "is_power_steering",
        "is_driver_seat_height_adjustable", "is_day_night_rear_view_mirror",
        "is_ecw", "is_speed_alert"
    ]
    for col in boolean_cols:
        val = st.selectbox(col.replace("_", " ").title(), ["Yes", "No"])
        user_input[col] = 1 if val == "Yes" else 0



   #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    # Encode categorical
    user_input['fuel_type'] = encoders['fuel_type'].transform([fuel_type])[0]
    user_input['rear_brakes_type'] = encoders['rear_brakes_type'].transform([rear_brakes_type])[0]
    user_input['transmission_type'] = encoders['transmission_type'].transform([transmission_type])[0]
    user_input['steering_type'] = encoders['steering_type'].transform([steering_type])[0]
    user_input['model'] = encoders['model'].transform([model_sel])[0]
    user_input['engine_type'] = encoders['engine_type'].transform([engine_type])[0]
    user_input['segment'] = encoders['segment'].transform([segment])[0]
    user_input['area_cluster'] = encoders['area_cluster'].transform([area_cluster])[0]

    # Interaction features
    eps = 1e-6
    user_input['power_to_weight'] = user_input['max_power_value'] / (user_input['gross_weight'] + eps)
    user_input['torque_to_weight'] = user_input['max_torque_value'] / (user_input['gross_weight'] + eps)
    user_input['car_age_ratio'] = user_input['age_of_car'] / (user_input['policy_tenure'] + 1.0)
    user_input['engine_efficiency'] = user_input['displacement'] / (user_input['max_power_value'] + eps)

    # Ensure correct feature order

    input_df = pd.DataFrame([user_input])



    dtypes = {
    'policy_tenure': 'float64',
    'age_of_car': 'float64',
    'age_of_policyholder': 'float64',
    'area_cluster': 'int64',
    'population_density': 'int64',
    'make': 'int64',
    'segment': 'int64',
    'model': 'int64',
    'fuel_type': 'int64',
    'engine_type': 'int64',
    'airbags': 'int64',
    'is_esc': 'int64',
    'is_adjustable_steering': 'int64',
    'is_tpms': 'int64',
    'is_parking_sensors': 'int64',
    'is_parking_camera': 'int64',
    'rear_brakes_type': 'int64',
    'displacement': 'int64',
    'cylinder': 'int64',
    'transmission_type': 'int64',
    'gear_box': 'int64',
    'steering_type': 'int64',
    'turning_radius': 'float64',
    'length': 'int64',
    'width': 'int64',
    'height': 'int64',
    'gross_weight': 'int64',
    'is_front_fog_lights': 'int64',
    'is_rear_window_wiper': 'int64',
    'is_rear_window_washer': 'int64',
    'is_rear_window_defogger': 'int64',
    'is_brake_assist': 'int64',
    'is_power_door_locks': 'int64',
    'is_central_locking': 'int64',
    'is_power_steering': 'int64',
    'is_driver_seat_height_adjustable': 'int64',
    'is_day_night_rear_view_mirror': 'int64',
    'is_ecw': 'int64',
    'is_speed_alert': 'int64',
    'ncap_rating': 'int64',
    'max_power_value': 'float64',
    'max_power_rpm': 'float64',
    'max_torque_value': 'float64',
    'max_torque_rpm': 'float64',
    'power_to_weight': 'float64',
    'torque_to_weight': 'float64',
    'car_age_ratio': 'float64',
    'engine_efficiency': 'float64'}

    # 1. Convert all columns to numeric using your dtypes dict
    for col, col_type in dtypes.items():
        input_df[col] = input_df[col].astype(col_type)

    # 2. Align to booster feature order
    booster_features = model.get_booster().feature_names
    for col in booster_features:
      if col not in input_df.columns:
          input_df[col] = 0
    input_df = input_df[booster_features]



    # 3. Convert to float32 for XGBoost
    for col in input_df.select_dtypes(include=['float64']).columns:
        input_df[col] = input_df[col].astype(np.float32)

    for col in input_df.select_dtypes(include=['int64']).columns:
        input_df[col] = input_df[col].astype(np.int32)







    if st.button("Predict Claim"):

        prediction = model.predict(input_df)[0]
        st.write("Prediction:", prediction)

